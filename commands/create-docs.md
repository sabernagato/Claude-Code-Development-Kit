您正在处理 VR 语言学习应用项目。用户已请求创建或重新生成文档，参数为："$ARGUMENTS"

## 自动加载的项目上下文：
@/CLAUDE.md
@/docs/ai-context/project-structure.md
@/docs/ai-context/docs-overview.md

## 关键：AI 优化文档原则
所有文档必须为 AI 消费和未来扩展而优化：
- **结构化和简洁**：使用清晰的章节、列表和层次结构。仅提供必要信息。
- **上下文完整**：包含必要的上下文、决策理由（"为什么"）和交叉引用。
- **面向模式**：明确体现架构模式、约定和数据流。
- **模块化和可扩展**：为部分更新和项目增长而构建结构。
- **交叉引用**：通过文件路径、函数名和稳定标识符链接相关概念


---

## 步骤 1：分析和制定策略

使用自动加载的项目上下文，分析用户请求并确定最佳文档策略。

### 1.1. 解析目标和评估复杂度
**操作**：分析 `$ARGUMENTS` 以识别 `target_path` 及其文档层级。

**目标分类：**
- **第 3 层（功能特定）**：包含 `/src/` 并以 `/CONTEXT.md` 结尾的路径
- **第 2 层（组件级别）**：以组件根目录 `/CONTEXT.md` 结尾的路径

**复杂度评估标准：**
- **代码库大小**：目标目录中的文件数量和代码行数
- **技术混合**：语言和框架的多样性（Python、TypeScript 等）
- **架构复杂度**：依赖图和跨组件导入
- **现有文档**：该区域中任何 CLAUDE.md 文件的存在和状态

### 1.2. 选择策略
基于自动加载的项目上下文，深入思考此文档生成任务和策略。根据评估，选择并宣布策略。

**策略逻辑：**
- **直接创建**：简单目标（< 15 个文件，单一技术，标准模式）
- **聚焦分析**：中等复杂度（15-75 个文件，2-3 种技术，一些新颖模式）
- **全面分析**：高复杂度（> 75 个文件，3+ 种技术，显著的架构深度）

---

## 步骤 2：信息收集（分析阶段）

基于选择的策略，收集必要的信息。

### 策略 A：直接创建
直接进入 **步骤 3.1**。在内容生成期间执行轻量级分析。

### 策略 B：聚焦或全面分析（子代理编排）

#### 2.1. 子代理角色
根据复杂度评估从这些专门角色中选择：
- **`Code_Analyzer`**：文件结构、实现模式、逻辑流程、编码约定
- **`Tech_Stack_Identifier`**：框架、库、依赖项、技术特定模式
- **`Architecture_Mapper`**：跨组件依赖、集成点、数据流
- **`Doc_Validator`**：现有文档准确性、差距、有价值的见解、内容重叠分析

#### 2.2. 启动子代理
**执行计划：**
- **聚焦分析（2-3 个代理）**：`Code_Analyzer` + `Tech_Stack_Identifier` + `Doc_Validator`（如果有现有文档）
- **全面分析（3-4 个代理）**：根据需要使用所有代理

**关键：使用单个消息中的多个 Task 工具调用并行启动代理以获得最佳性能。**

**任务模板：**
```
任务："作为 [Agent_Role]，分析位于 `[target_path]` 的代码库以支持文档生成。

您的重点：[角色特定目标，例如，'识别所有架构模式和依赖项']

标准工作流程：
1. 查看自动加载的项目上下文（CLAUDE.md、project-structure.md、docs-overview.md）
2. 为您的专业领域分析目标路径
3. 返回用于文档生成的结构化发现

返回针对此角色的全面发现摘要。"
```

---

## 步骤 3：文档生成

深入思考如何综合发现并生成全面的文档。使用收集的信息，智能地综合并生成文档内容。

### 3.1. 内容综合与生成

#### 直接创建（无子代理）
**代码优先分析方法：**
1. **目录结构分析**：使用 Glob/LS 映射文件组织和用途
2. **导入依赖分析**：使用 Grep 识别集成模式和依赖项
3. **模式提取**：读取关键文件以识别架构模式和编码约定
4. **技术使用分析**：检测框架、库和技术特定模式
5. **现有文档评估**：读取任何当前的 CLAUDE.md 文件以获取有价值的见解

#### 子代理策略
**综合集成过程：**
1. **编译核心发现**：合并代理发现以立即生成文档
2. **提取跨层模式**：识别可能影响基础文档的系统范围模式
3. **解决信息冲突**：当代码与现有文档矛盾时，使用代码作为真实来源
4. **识别内容差距**：基于分析找到需要新文档的区域
5. **应用项目约定**：使用来自自动加载的 /CLAUDE.md 的编码标准和命名约定
6. **内容重叠识别**：从 Doc_Validator 发现中，识别与目标内容重叠的现有文档，以便后续迁移分析

#### 内容生成过程
**两种方法通用：**
1. **选择模板**：根据目标分类选择第 2 层或第 3 层
2. **应用内容处理策略**：
   - **保留**：经过验证的现有文档中的架构见解
   - **增强**：使用新发现的实现细节扩展现有模式
   - **替换**：与当前代码现实冲突的过时内容
   - **创建**：未记录的模式和决策的新文档
3. **填充章节**：用综合发现填充模板章节
4. **确保完整性**：包括架构决策、模式、依赖项和集成点
5. **遵循 AI 优化原则**：为 AI 消费构建结构，具有清晰的交叉引用

### 3.2. 模板指南

**第 2 层（组件级别）：**
```markdown
# [组件名称] - 组件上下文

## 目的
[组件目的和关键职责]

## 当前状态：[状态]
[状态与演变上下文和理由]

## 组件特定开发指南
[技术特定模式和约定]

## 主要子系统组织
[基于实际代码组织的高级结构]

## 架构模式
[核心模式和设计决策]

## 集成点
[依赖项和与其他组件的连接]
```

**第 3 层（功能特定）：**
```markdown
# [功能区域] 文档

## [区域] 架构
[关键架构元素和集成模式]

## 实现模式
[核心模式和错误处理策略]

## 关键文件和结构
[文件组织与用途]

## 集成点
[这如何与系统的其他部分集成]

## 开发模式
[测试方法和调试策略]
```

---

## 步骤 4：最终确定和整理

### 4.1. 编写文档文件
**操作**：将生成的内容写入目标路径。

### 4.2. 更新文档注册表

#### 更新 docs-overview.md
**对于新文档文件：**
- 添加到适当的层级部分（功能特定或组件级别）
- 遵循既定的条目格式，包含路径和描述
- 在各部分内保持字母顺序

**对于更新的现有文件：**
- 验证条目存在且描述是最新的
- 更新任何已更改的目的或范围

#### 更新项目结构（如需要）
**如果创建了新目录：**
- 在 `/docs/ai-context/project-structure.md` 中更新文件树
- 添加解释用途的目录注释
- 保持树结构格式和组织

### 4.3. 质量验证
**操作**：验证层级适当性、代码准确性、交叉引用有效性以及与现有文档模式的一致性。

### 4.4. 第 1 层验证与建议

**操作**：将发现的代码模式与基础文档进行比较，以识别不一致性和改进机会。

#### 过程
1. **发现第 1 层文件**：读取 `/docs/ai-context/docs-overview.md` 以识别所有基础文档文件
2. **读取基础文档**：加载发现的第 1 层文件以了解已记录的架构
3. **跨层分析**：使用前面步骤的分析发现，比较：
   - **技术栈**：发现的框架/工具与已记录的栈
   - **架构模式**：实现现实与已记录的决策
   - **集成点**：实际依赖项与已记录的集成
4. **生成建议**：输出基于证据的基础文档更新建议

### 4.5. 内容迁移和冗余管理

**操作**：智能管理内容层次结构并消除跨文档层级的冗余。

#### 交叉引用分析
1. **识别相关文档**：使用步骤 3.1 综合的 Doc_Validator 发现和目标层级分类，识别可能包含重叠内容的现有文档
2. **内容重叠检测**：将新文档内容与现有文件进行比较以识别：
   - **重复信息**：应该只存在于一个位置的相同内容
   - **层次重叠**：存在于错误层级的内容（架构文档中的实现细节）
   - **交叉引用机会**：应该链接而不是复制的内容

#### 智能内容迁移策略
**内容分类框架：**
- **层级适当的重复**：高级架构上下文可以在第 2 层和第 3 层以不同的详细程度存在
- **迁移候选**：详细的实现模式、特定代码示例、功能特定的技术细节
- **引用目标**：稳定的架构决策、设计理由、横切关注点

**迁移决策逻辑：**
1. **对于第 3 层创建（功能特定）**：
   - **从第 2 层提取**：将功能特定的实现细节移动到新的第 3 层文件
   - **在第 2 层保留**：保留高级架构概述和设计决策
   - **添加交叉引用**：将第 2 层概述链接到详细的第 3 层实现

2. **对于第 2 层创建（组件级别）**：
   - **从多个第 3 层合并**：聚合现有功能文档的架构见解
   - **保留第 3 层细节**：在功能文档中保留实现细节
   - **创建导航结构**：添加对相关第 3 层文档的引用

#### 内容迁移执行
**迁移过程：**
1. **识别源内容**：提取应该从现有文件迁移的内容
2. **内容转换**：将内容调整到适当的层级（架构与实现焦点）
3. **更新源文件**：删除已迁移的内容并添加对新位置的交叉引用
4. **保留上下文**：确保源文件在内容删除后保持连贯性
5. **验证迁移**：确认没有损坏的引用或丢失的信息

**安全框架：**
- **保守默认值**：不确定时，在原始位置保留内容并添加引用
- **内容保留**：永远不要在其他地方创建内容之前删除内容
- **迁移可逆性**：记录所有迁移以便在需要时启用回滚

---

## 步骤 5：生成摘要

提供包括以下内容的全面摘要：

### 文档创建结果
- **文档类型和位置**（第 2 层或第 3 层）
- **使用的策略**（直接创建、聚焦分析或全面分析）
- **记录的关键模式**（架构决策、实现模式）
- **进行的注册表更新**（docs-overview.md、project-structure.md 条目）

### 第 1 层架构智能
**基于步骤 4.4 分析，提供结构化建议：**

#### 需要的关键更新
- **文件**：[特定的基础文档路径]
- **问题**：[具有证据的特定不一致性]
- **建议**：[需要的特定更新]
- **证据**：[支持建议的代码引用]

#### 架构增强机会
- **识别的差距**：[缺失的基础文档区域]
- **范围**：[应该记录什么]
- **理由**：[为什么这值得基础文档]
- **实现证据**：[发现的代码模式]

#### 文档健康评估
- **对齐分数**：[代码和文档之间的整体一致性]
- **最准确的区域**：[与实现匹配良好的基础文档]
- **需要关注的区域**：[存在重大差距/不一致的基础文档]
- **系统改进优先级**：[解决问题的建议顺序]

#### 内容迁移结果
**记录所有内容层次更改和冗余消除：**

- **内容迁移自**：[源文件路径] → [目标文件路径]
  - **内容类型**：[例如，"实现模式"、"技术细节"、"架构决策"]
  - **理由**：[为什么此内容属于目标层级]
  - **添加的交叉引用**：[在层级之间创建的导航链接]

- **内容保留在**：[更广泛的层级文件]
  - **内容类型**：[例如，"架构概述"、"设计决策"、"集成模式"]
  - **理由**：[为什么此内容保留在更广泛的层级]

- **消除的冗余**：
  - **删除的重复内容**：[消除的特定重复]
  - **层次修正**：[移动到适当层级的内容]
  - **引用合并**：[链接替换重复的区域]

- **迁移安全**：
  - **内容保留**：[确认没有信息丢失]
  - **回滚信息**：[记录更改以便可能的逆转]
  - **验证结果**：[确认没有损坏的引用]

#### 下一步文档步骤（可选建议）
- **功能特定文档候选**：[建议有价值的额外第 3 层文档]
- **跨组件文档需求**：[识别需要类似分析的其他组件]
- **消除的文档债务**：[解决的冗余和不一致性摘要]

---

现在根据请求继续创建/重新生成文档：$ARGUMENTS
